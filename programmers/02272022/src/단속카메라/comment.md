정렬을 잘 이용하면 쉽게 풀 수 있는 문제였다.

처음에는 차가 진입한 순간 -> 차가 통과한 순간 순으로 정렬을 수행했는데,

    Arrays
                .stream(routes)
                .sorted((r1, r2) -> {
                    if (r1[0] == r2[0]) {
                        return r1[1] - r2[1];
                    } else return r1[0] - r2[0];
                })

위 방법으로 수행했을 때, 반례가 존재한다. (routes: {{-3, 0}, {-2, -1}, {1, 2}} 일 때 정답: 2)

반례를 만족시키기 위해서, 차가 통과한 순간 순으로 정렬을 수행하도록 변경했다.
        
        Arrays
                .stream(routes)
                .sorted(Comparator.comparingInt(r -> r[1]))

이상하게 효율성 테스트 중 한 테스트가 계속해서 실패했는데, 

알고보니 정렬을 수행한 배열을 다시 새로운 변수에 할당해 메모리 활용 부분에서 실패한 것처럼 보인다.

        Arrays.sort(routes, Comparator.comparingInt(r -> r[1]));

그래서 parameter 로 받은 routes 변수를 정렬하도록 코드를 변경했다.

정렬을 수행하고, greedy 알고리즘이라는 것을 기억해 첫번째 차가 나간 시간(out 이라고 하겠다)을 기준으로 

기준 시간보다 같거나 작은 out 을 갖는 원소들을 무시하고, 넘어갈 경우 기준 값을 갱신시켜주면서 계산하면 O(n) 으로 해결할 수 있다. (정렬 제외)